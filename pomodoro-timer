#!/usr/bin/env python

import subprocess
import argparse
import time
from gtknotification import GTKNotification
from os.path import realpath, dirname
from sys import stdout
import inquirer

# Default dimensions just in case
DEFAULT_HEIGHT = 24
DEFAULT_WIDTH = 80
# Arguments
parser = argparse.ArgumentParser(description="Fancy pomodoro timer script")

parser.add_argument("-w", "--work", action="store",
                    type=int, help="Number of minutes of work",
                    default=25)
parser.add_argument("-r", "--rest", action="store",
                    type=int, help="Number of minutes of rest",
                    default=5)
parser.add_argument("-f", "--font", action="store",
                    help="Custom font file",
                    default=dirname(realpath(__file__))+'/font.txt')
parser.add_argument("-t", "--total", action="store_true",
                    help="Show the total timer")
parser.add_argument("-n", "--nocenter", action="store_true",
                    help="Do not center timer (more efficient)")
parser.add_argument("-sc", "--show_clock", action="store_true",
                    help="Do not center timer (more efficient)",
                    default=False)
parser.add_argument("-ni", "--no_inquirer", action="store_true",
                    help="Do not prompt inquirer",
                    default=False)
parser.add_argument("-il", "--infinite_loop", action="store_true",
                    help="Infinite loop, does not ask if you are done",
                    default=False)
args = parser.parse_args()
centered = not args.nocenter
show_total = args.total
work_seconds = args.work * 60
rest_seconds = args.rest * 60
fontFile = args.font
show_clock = args.show_clock

if not args.no_inquirer:
    questions = [
        inquirer.List('params_from',
                    message="Use default or you want to set new work-rest time?",
                    choices=['Use default', 'Let me choose'],
                ),
        inquirer.Text('work_seconds',
                    message="Set work duration (in miniutes)",
                    default='25'
                ),
        inquirer.Text('rest_seconds',
                    message="Set rest duration (in miniutes)",
                    default='5'
                ),
        ]
    answers = inquirer.prompt(questions[:1])
    if answers['params_from'] == 'Let me choose':
        answers = inquirer.prompt(questions[1:])
        work_seconds = int(answers['work_seconds']) * 60
        rest_seconds = int(answers['rest_seconds']) * 60


# Turn string into blocky ascii representation
# Supports 0-9, colon


def asciiFormat(string, font):
    # enumerate numbers and colons
    string = list(
        map(int, [c.replace(":", "10").replace("/", "11") for c in list(string)]))
    height = len(font[0])

    frame = ""
    # fill frame top to bottom
    for i in range(height):
        # loop through string
        for char in string[:-1]:
            frame += font[char][i] + " "
        # dirty hack to have no space at the end
        frame += font[string[-1]][i]

        frame += "\n"
    return frame[:-1]


def center(frame, termDimensions):
    # Pad with spaces and newlines to center
    if centered:
        termHeight = termDimensions[0]
        termWidth = termDimensions[1]
        frame = frame.split("\n")
        frameWidth = max(map(len, frame))
        frameHeight = len(frame)
        # pad horizontally
        pad = " " * int((termWidth - frameWidth) / 2)
        frame = "\n".join([(pad + line + pad) for line in frame])

        # pad vertically
        pad = "\n" * int((termHeight - frameHeight) / 2)
        frame = pad + frame + pad
    return frame

def sand(left_time, total_time, termDimensions):
    termHeight = termDimensions[0] - 2
    termWidth = termDimensions[1]
    percentage = int((1 - (left_time / total_time)) * termWidth)
    bar = '‚ñà'*percentage + '\n'
    all = termHeight*bar
    return all


def clear():
    # Clear the screen
    print("\033c", end='')


def getTermDimensions():
    # Get the terminal dimensions [height, width]
    try:
        dimensions = subprocess.check_output(['stty', 'size']).split()
        return list(map(int, dimensions))
    except subprocess.CalledProcessError:
        return [DEFAULT_HEIGHT, DEFAULT_WIDTH]


# Load font file
with open(fontFile, "r") as f:
    font = f.read().split("\n<---->\n")
    font = [symbol.split("\n") for symbol in font]


def print_progress_bar(left_time, total_time, term_dimension):
    try:
        percentage = 1 - (left_time / total_time)
    except:
        print('-' * term_dimension[1])
        return
    try:
        number_of_squares = int(term_dimension[1] * percentage)
    except:
        print('=' * term_dimension[1])
        return
    print('=' * number_of_squares, end='')
    print('-' * (term_dimension[1] - number_of_squares), end='')


def writing_loop(seconds, message, color):
    initial_time_seconds = seconds
    initialTime = "%s:%02d" % divmod(seconds, 60)
    while seconds >= 0:
        t = "%s:%02d" % divmod(seconds, 60)
        clear()
        # Color
        print(color, end='')
        # Print the clock and the message
        # if show_total is True:
            # print(center(asciiFormat(
                # '{0}/{1}'.format(t, initialTime), font), getTermDimensions()), end="")
        # else:
            # print(center(asciiFormat(t, font), getTermDimensions()), end="")
        print(sand(seconds, initial_time_seconds, getTermDimensions()))
        # Show message
        if show_clock:
            print(message+f' for {(seconds//60)+1} mins!')
        else:
            print(message)
        # Show progress bar
        print_progress_bar(seconds, initial_time_seconds, getTermDimensions())
        # Remove color
        print('\033[0m', end='')
        stdout.flush()

        seconds -= 1
        try:
            time.sleep(1)
        except KeyboardInterrupt:
            clear()
            print('Press CTRL+C again to quit')
            try:
                time.sleep(1)
                return
            except KeyboardInterrupt:
                quit(0)

def what_next(current_state):
    if current_state == 'Work':
        next_state = 'Rest'
    elif current_state == 'Rest':
        next_state = 'Work'
    questions = [
        inquirer.List('next_state',
                    message=f"{work_seconds/60} mins of {current_state} are done, what do you want to do next?",
                    choices=[next_state, current_state, "I'm done"],
                    default=next_state)
        ]
    answers = inquirer.prompt(questions)
    next = answers['next_state']
    return next



# Pomodoro!

mynotification = GTKNotification()
done = False
while not done:
    # Work timer
    writing_loop(work_seconds, 'You Should Focus', '\033[92m')
    # Send notification about resting time
    mynotification.send_notification('Pomodoro Timer', 'Rest time üõãÔ∏è')
    next_state = what_next('Work')
    if next_state == "I'm done":
        break
    # Rest timer
    writing_loop(rest_seconds, 'You Should Rest', '\033[94m')
    next_state = what_next('Rest')
    if next_state == "I'm done":
        break
    # Send notification about work time
    mynotification.send_notification('Pomodoro Timer', 'Work time üíª')
